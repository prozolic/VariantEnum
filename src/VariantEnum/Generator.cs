using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace VariantEnum;

[Generator(LanguageNames.CSharp)]
public partial class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("VariantEnum.g.cs", """
using System;

namespace VariantEnum;

public class VariantValueTypeAttribute : Attribute
{
    public VariantValueTypeAttribute(params Type[] types)
    {
    }
}
""");
        });

        // -Variant
        var variantEnumSource = context.SyntaxProvider
            .CreateSyntaxProvider((node, ct) =>
            {
                if (node.IsKind(SyntaxKind.EnumDeclaration))
                {
                    var enumSyntax = node as EnumDeclarationSyntax;
                    if (enumSyntax == null) return false;

                    // enum XXXX
                    var enumName = enumSyntax.Identifier.Text;
                    return enumName.EndsWith("Variant");
                }

                return false;
            }, static (context, ct) => context)
            .Combine(context.CompilationProvider)
            .Select((gsc, ct) =>
            {
                var (context, compilation) = gsc;
                var enumSyntax = (EnumDeclarationSyntax)context.Node;
                var enumName = enumSyntax.Identifier.Text;

                var variantAttribute = compilation.GetTypeByMetadataName("VariantEnum.VariantValueTypeAttribute");
                var members = enumSyntax.Members.Select(m =>
                {
                    var VariantValueTypeAttribute = m.AttributeLists
                        .SelectMany(attr => attr.Attributes)
                        .FirstOrDefault(attr => attr.Name.ToString() == "VariantValueType")
                        ?.ArgumentList;
                    if (VariantValueTypeAttribute == null)
                    {
                        return new VariantValueTypeMemberDeclarationSyntax(m, false);
                    }

                    var argsTypes = VariantValueTypeAttribute.Arguments.Select(arg =>
                    {
                        var type = arg.Expression as TypeOfExpressionSyntax;
                        if (type == null) return null;

                        var typeSymbol = compilation.GetSemanticModel(type.Type.SyntaxTree).GetTypeInfo(type.Type).Type;
                        return typeSymbol;
                    });

                    var attribute = SyntaxFactory.Attribute(
                        SyntaxFactory.ParseName(variantAttribute!.ToDisplayString()),
                        SyntaxFactory.ParseAttributeArgumentList($"({string.Join(", ", argsTypes)})"));

                    return new VariantValueTypeMemberDeclarationSyntax(
                        m.AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList(attribute))),
                        true);
                }).ToImmutableArray();

                return new VariantEnumContext(enumSyntax, compilation, members);
            });

        context.RegisterSourceOutput(variantEnumSource, Emit);

    }

    private void Emit(SourceProductionContext context, VariantEnumContext source)
    {
        var syntax = source.EnumDeclarationSyntax;

        if (source.EnumDeclarationSyntax.IsNested())
        {
            // error
            return;
        }

        var varientEnumName = source.EnumDeclarationSyntax.Identifier.Text.Split(["Variant"], StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();

        context.AddSource($"{varientEnumName}_generated.g.cs", Emitter.Emit(source, varientEnumName));
    }


    internal class Emitter
    {
        public static string Emit(VariantEnumContext context, string varientEnumName)
        {
            var ns = context.Symbol!.ContainingNamespace.IsGlobalNamespace ? string.Empty : $"namespace {context.Symbol!.ContainingNamespace};";
            var code = @$"
// <auto-generated> This .cs file is generated by ValueEnum. </auto-generated>
#nullable enable
#pragma warning disable CS0219 // The variable 'variable' is assigned but its value is never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment.
#pragma warning disable CS8602 // Dereference of a possibly null reference.
#pragma warning disable CS8603 // Possible null reference return.
#pragma warning disable CS8604 // Possible null reference argument for parameter.
#pragma warning disable CS8619 // Possible null reference assignment fix

using System;

{ns}

public abstract record {varientEnumName} : ISpanFormattable
{{
{EmitMembers(context, varientEnumName)}
    public abstract bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider? provider = null);

    public abstract string ToString(string? format, IFormatProvider? formatProvider);

{EmitMethod(context, varientEnumName)}

}}";
            return code;
        }

        private static string EmitMembers(VariantEnumContext context, string varientEnumName)
        {
            var builder = new StringBuilder();

            foreach(var member in context.Members)
            {
                var code = @$"    public sealed record {member.MemberSyntax.Identifier.Text}{EmitVarient(context, member)} : {varientEnumName}
    {{
{EmitDefault(member)}

{EmitSpanFormattable(member, varientEnumName)}
    }}
";
                builder.Append(code);
            }
            return builder.ToString();
        }

        private static string EmitDefault(VariantValueTypeMemberDeclarationSyntax syntax)
        {
            if (syntax.MemberSyntax.AttributeLists.Count == 0)
            {
                var code = @$"        public static {syntax.MemberSyntax.Identifier.Text} Default => new {syntax.MemberSyntax.Identifier.Text}();";
                return code;
            }
            else
            {

                var index = 0;
                var attr = syntax.MemberSyntax.AttributeLists.Skip(1).FirstOrDefault();
                var arguments = attr.Attributes[0]!.ArgumentList!.Arguments;
                var builder = new StringBuilder();
                foreach (var a in arguments)
                {
                    builder.Append($"args{index++}: default");

                    if (index < arguments.Count)
                        builder.Append(", ");
                }

                var code = @$"        public static {syntax.MemberSyntax.Identifier.Text} Default => new {syntax.MemberSyntax.Identifier.Text}({builder});";
                return code;
            }
        }

        private static string EmitVarient(VariantEnumContext context, VariantValueTypeMemberDeclarationSyntax syntax)
        {
            if (!syntax.EnableVariantValueType) return string.Empty;

            var builder = new StringBuilder();
            var index = 0;
            var attr = syntax.MemberSyntax.AttributeLists.Skip(1).FirstOrDefault();
            var arguments = attr.Attributes[0]!.ArgumentList!.Arguments;
            builder.Append("(");
            foreach (var a in arguments)
            {
                builder.Append($"{a} args{index++}");

                if (index < arguments.Count)
                    builder.Append(", ");
            }
            builder.Append(")");

            return builder.ToString();
        }

        private static string EmitSpanFormattable(VariantValueTypeMemberDeclarationSyntax syntax, string varientEnumName)
        {
            var length = syntax.MemberSyntax.Identifier.Text.Length;

            var code = @$"        public override bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider? provider = null)
        {{
            if (destination.Length < {length})
            {{
                charsWritten = 0;
                return false;
            }}

            ""{syntax.MemberSyntax.Identifier.Text}"".CopyTo(destination.Slice(0, {length}));
            charsWritten = {length};
            return true;
        }}

        public override string ToString(string? format, IFormatProvider? formatProvider)
            => ToString();
";
            return code;
        }

        private static string EmitMethod(VariantEnumContext context, string varientEnumName)
        {
            var builder = new StringBuilder();
            builder.AppendLine($"    public static int Count => {context.Members.Length};");
            builder.AppendLine();
            builder.AppendLine("    public static string[] GetNames()");
            builder.AppendLine("    {");
            builder.Append("        return ");
            builder.Append("[");
            for (var index = 0; index < context.Members.Length; index++)
            {
                builder.Append($@"""{context.Members[index].MemberSyntax.Identifier.Text}""");
                if (index < context.Members.Length - 1)
                    builder.Append(", ");
            }
            builder.AppendLine("];");
            builder.AppendLine("    }");
            builder.AppendLine(EmitConvertMethod(context, varientEnumName));
            builder.Append(EmitParseMethod(context, varientEnumName));

            return builder.ToString();
        }

        private static string EmitConvertMethod(VariantEnumContext context, string varientEnumName)
        {
            var convertBuilder = new StringBuilder();
            foreach(var m in context.Members)
            {
                convertBuilder.AppendLine($"            {m.MemberSyntax.Identifier.Text} {m.MemberSyntax.Identifier.Text.ToLower()} => {varientEnumName}Variant.{m.MemberSyntax.Identifier.Text},");
            }
            convertBuilder.AppendLine($"            _ => throw new NotImplementedException(nameof({varientEnumName.ToLower()}))");

            var tryConvertBuilder = new StringBuilder();
            foreach (var m in context.Members)
            {
                tryConvertBuilder.AppendLine($"            case {m.MemberSyntax.Identifier.Text}:");
                tryConvertBuilder.AppendLine($"                {varientEnumName.ToLower()}Variant = {varientEnumName}Variant.{m.MemberSyntax.Identifier.Text};");
                tryConvertBuilder.AppendLine($"                return true;");
            }

            var code = @$"
    public static {varientEnumName}Variant Convert({varientEnumName} {varientEnumName.ToLower()})
    {{
        return {varientEnumName.ToLower()} switch
        {{
{convertBuilder}
        }};
    }}

    public static bool TryConvert({varientEnumName} {varientEnumName.ToLower()}, out {varientEnumName}Variant {varientEnumName.ToLower()}Variant)
    {{
        switch({varientEnumName.ToLower()})
        {{
{tryConvertBuilder}
        }}
        {varientEnumName.ToLower()}Variant = default;
        return false;
    }}
";
            return code;
        }
        private static string EmitParseMethod(VariantEnumContext context, string varientEnumName)
        {
            var parseBuilder = new StringBuilder();
            foreach (var m in context.Members)
            {
                var memberName = m.MemberSyntax.Identifier.Text;
                parseBuilder.AppendLine($"            \"{memberName}\" => {memberName}.Default,");
            }
            parseBuilder.AppendLine($"            _ => throw new NotImplementedException(nameof(value))");

            var tryConvertBuilder = new StringBuilder();
            foreach (var m in context.Members)
            {
                var memberName = m.MemberSyntax.Identifier.Text;
                tryConvertBuilder.AppendLine($@"            case ""{m.MemberSyntax.Identifier.Text}"":");
                tryConvertBuilder.AppendLine($"                {varientEnumName.ToLower()} = {memberName}.Default;");
                tryConvertBuilder.AppendLine($"                return true;");
            }

            var code = @$"    public static {varientEnumName} Parse(string value)
    {{
        return value switch
        {{
{parseBuilder}
        }};
    }}

    public static bool TryParse(string value, out {varientEnumName} {varientEnumName.ToLower()})
    {{
        switch (value)
        {{
{tryConvertBuilder}
        }}
        {varientEnumName.ToLower()} = default;
        return false;
    }}
";
            return code;
        }
    }
}